cel-parser: A Clojure parser for the CEL language
=================================================

This library provides a parser and evaluation engine for the language
specified in https://github.com/google/cel-spec/.

## Usage

The simplest way to run through a CEL expression is to use
`exoscale.cel.parser/parse-eval` which parses an expression into
a program and runs it against the provided input. Input is provided
in the form of bindings: a map of symbol to install in the program's
namespace to its value.

``` clojure
(parse-eval "true")
(parse-eval {:bindings {:x "world"}} "'hello, ' + x + '!'")
```

When repeatedly running the same expression, the action can be
decomposed in two phases, first building the program with
`exoscale.cel.parser/make-program`, and then running it with
`exoscale.cel.parser/eval-for`:

``` clojure
(def my-program (make-program "'hello, ' + x + '!'"))

(eval-for my-program {:x "world"})
```

When execution results in an error, an exception is returned, not
thrown by default. To throw upon error returns, `throw-on-error?`
may be added to the input map.

## Limitations

The following is currently not supported in this parser:

- Namespaces
- Namespaced keys in maps; Resulting CEL expressions will get unqualified string keys
- Protobuf object creation; For now, objects are expected to be supplied as maps


## Language support

The majority of the language functionality is supported and validated
through tests generated by the testdata
https://github.com/google/cel-spec/tree/master/tests/simple/testdata

Some small divergences exist:

- Aggregate types may return `false` instead of an overload error for some
  comparisons (notably maps).
- Integer conversions are slighlty more relaxed than the spec allows for, for
  instance `int(-9223372036854775807.0)` yields a valid int in this parser
  but is expected to fail in the spec
